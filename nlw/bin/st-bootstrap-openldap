#!/usr/bin/env perl
# @COPYRIGHT@

use strict;
use warnings;
use POSIX;
use FindBin;
use lib "$FindBin::Bin/../lib";
use Getopt::Long;
use Pod::Usage;
use File::Slurp qw(slurp write_file);
use File::Temp qw(tempfile);
use Fcntl qw(SEEK_SET);
use Socialtext::AppConfig;
use Socialtext::System qw(shell_run);
use Socialtext::LDAP;

###############################################################################
# Hang onto the command line arguments, in case we need to sudo.
my @ORIGINAL_ARGV = @ARGV;

###############################################################################
# Read in our command line arguments.
my $daemonize = 0;
my $dataset;
my ($help, $man);
GetOptions(
    'daemonize' => \$daemonize,
    'dataset=s' => \$dataset,
    'help|?'    => \$help,
    'man'       => \$man,
) || pod2usage(1);
pod2usage(1) if ($help);
pod2usage( -exitstatus=>0, -verbose=>2 ) if ($man);

###############################################################################
# On appliances, this *must* be run as "root".
if (   Socialtext::AppConfig->is_appliance()
    && Socialtext::AppConfig->startup_user_is_human_user()) {
    shell_run('sudo', $^X, $0, @ORIGINAL_ARGV);
    exit;
}

###############################################################################
# Load the OpenLDAP bootstrapper.  Has to be done *after* we sudo, though;
# ST::Hub can't load on an appliance as a human User.
require Socialtext::Bootstrap::OpenLDAP;

###############################################################################
# Perform the action specified on the command line
my %actions = (
    'start'     => \&start,
    'stop'      => \&stop,
    'status'    => \&status,
    'delete'    => \&delete_dn,
);
my $action = shift @ARGV;
pod2usage(1) unless ($action && exists $actions{$action});

$actions{$action}->();

###############################################################################
# All done; exit peacefully.
exit;


###############################################################################
# Start.  Bootstraps a copy of OpenLDAP, and adds data to it.  This method does
# *NOT* return.
sub start {
    my $pidfile = _pidfile();

    # kill off any other running copy of st-bootstrap-openldap; we only allow
    # for a single copy of this to be running per-user.
    _kill_running_copy_of_ourselves();

    # get the LDIF data we want to add; once we daemonize we'll lose any
    # filehandle that we may have had to DATA.
    my $ldif_data = slurp($dataset ||= \*DATA);

    # daemonize ourselves, if needed.
    #
    # we'll keep an eye out for the PID file which is generated by the child
    # process when its finished bootstrapping OpenLDAP.
    if ($daemonize) {
        my $child_pid = _daemonize();
        if ($child_pid) {
            # we're in the parent; wait for child to start, then exit.
            print "waiting for OpenLDAP to start...\n";
            for (0 .. 10) {
                last if (-e $pidfile);
                sleep(1);
            }
            status();
            exit;
        }
    }

    # bootstrap OpenLDAP, and populate it with data.
    #
    # also set up a signal handler so that we properly shut down OpenLDAP when
    # we get killed off
    my $openldap;
    $SIG{INT} = sub { undef $openldap; exit; };
    $openldap = Socialtext::Bootstrap::OpenLDAP->new(
        base_dn => 'dc=socialtext,dc=com',
    );

    my $ldif_fh = tempfile();
    $ldif_fh->print($ldif_data);
    seek $ldif_fh, 0, SEEK_SET;
    $openldap->add_ldif($ldif_fh) || die "can't add data to LDAP server\n";
    $ldif_fh->close();

    # update PID file to show that *we* are running.
    #
    # we do this *after* starting OpenLDAP, so that if we're daemonizing then
    # our parent process knows that we're all done.
    write_file($pidfile, { atomic => 1 }, $$);

    # let user know we're done, then pause indefinately.
    print qq{
OpenLDAP has been bootstrapped, is running, has been populated with users, and
the Wiki has been configured to use it as a source for users.

Press ^C to abort.
};
    sleep(1) while 1;
}

###############################################################################
# Stop.  Kills off any running copy, and resets the user/group factories back
# to their default value.
sub stop {
    # kill off any other running copy of st-bootstrap-openldap
    unless (_kill_running_copy_of_ourselves()) {
        print "no OpenLDAP running; nothing to stop\n";
    }

    # reset the (user|group)_factories back to the default
    my $appconfig = Socialtext::AppConfig->new();
    $appconfig->set( 'user_factories', 'Default' );
    $appconfig->set( 'group_factories', 'Default' );
    eval {
        $appconfig->write();
    }
}

###############################################################################
# Status.  Checks to see if there's a bootstrapped copy of OpenLDAP running
# already.
sub status {
    # check if there's a copy of ourselves already running
    my $pidfile = _pidfile();
    if (-e $pidfile) {
        my $pid = slurp($pidfile);
        if (_is_running($pid)) {
            print "$0 running; pid $pid\n";
            exit;
        }
    }
    print "$0 not running\n";
}

###############################################################################
# Delete.  Deletes an entry from the LDAP directory, by its DN.
sub delete_dn {
    # get the DN to delete
    my $dn = shift @ARGV;
    unless ($dn) {
        die "no DN given to delete from LDAP directory.\n";
    }

    # connect to LDAP
    my $st_ldap = Socialtext::LDAP->new();
    unless ($st_ldap) {
        die "unable to connect to LDAP.\n";
    }

    # delete the DN from LDAP, using direct Net::LDAP methods
    my $mesg = $st_ldap->{ldap}->delete($dn);
    if ($mesg->code()) {
        die "unable to remove DN from LDAP; " . $mesg->error() . "\n";
    }
    print "entry removed\n";
}

###############################################################################
# Returns the full path to the file we use to hold our PID.
sub _pidfile {
    return "/tmp/st-bootstrap-openldap-$<.pid";
}

###############################################################################
# Check to see if the given PID is running.
sub _is_running {
    return kill(0, shift);
}

###############################################################################
# Daemonizes the process.  Returns the PID of the child to the parent, returns
# nothing to the child.
sub _daemonize {
    my $pid = fork();
    return $pid if $pid;

    ### we're in the child process...
    ###
    ### code here loosely based on that in Proc::Daemon

    # detach ourselves from the terminal
    POSIX::setsid();

    # close all other open file descriptors
    #
    # NOTE: we close "2 .." instead of "0 .." as slapd fails to start if we
    # close 0,1.  Unsure why (as we're going to reopen them to /dev/null
    # anways), but it does.
    my $openmax = POSIX::sysconf( &POSIX::_SC_OPEN_MAX );
    $openmax = 64 if ((!defined $openmax) || ($openmax < 0));

    POSIX::close($_) foreach (2 .. $openmax);

    # re-open standard descriptors, all to /dev/null
    open STDIN,  '+>/dev/null';
    open STDOUT, '+>&STDIN';
    open STDERR, '+>&STDIN';

    return;
}

###############################################################################
# Kills off a running copy of ourselves, *if* one is running.
sub _kill_running_copy_of_ourselves {
    my $pidfile  = _pidfile();
    my $did_kill = 0;

    if (-e $pidfile) {
        my $pid = slurp($pidfile);
        if (_is_running($pid)) {
            print "killing off $0...\n";
            kill(2, $pid);
            $did_kill ++;

            for (0 .. 5) {
                sleep(1);
                goto DONE_KILLING_OFF_SELF unless _is_running($pid);
            }

            print "... didn't die off; killing -9 ...\n";
            kill(9, $pid);
            for (0 .. 5) {
                sleep(1);
                goto DONE_KILLING_OFF_SELF unless _is_running($pid);
            }

            die "... can't kill $0; aborting\n";
        }
    }

  DONE_KILLING_OFF_SELF:
    unlink $pidfile;
    return $did_kill;
}

=head1 NAME

st-bootstrap-openldap - Bootstrap OpenLDAP instance for testing

=head1 SYNOPSIS

  st-bootstrap-openldap [options] <action>

  Actions:
    start           Start an OpenLDAP instance for testing
        --daemonize         Daemonize, running OpenLDAP in the background
        --dataset <ldif>    Specify LDIF file to use for data set
    stop            Stop any running OpenLDAP instance
    status          See if an OpenLDAP instance is running
    delete <dn>     Delete the given DN from running OpenLDAP instance

  Options:
    --help/-?       Brief help message
    --man           Full documentation

  Example:
    st-bootstrap-openldap start --daemonize
    st-bootstrap-openldap start --dataset /path/to/big.ldif
    st-bootstrap-openldap delete "cn=devnull3,dc=socialtext,dc=com"

=head1 DESCRIPTION

C<st-bootstrap-openldap> is a command line utility to help bootstrap an
OpenLDAP instance for testing.

When bootstrapped, the OpenLDAP instance is populated with some test data and
Socialtext is then configured to use this instance as a User/Group Factory.

This script automatically kills any running copy of itself on subsequent
starts.  Its safe to just do C<st-bootstrap-openldap start --daemonize>
repeatedly; each time you'll get a brand new OpenLDAP instance.

=head1 OPTIONS

=over

=item B<start>

Kills off any running OpenLDAP instance and starts a new one.

=over

=item --daemonize

When starting an OpenLDAP instance, daemonize it and fire it off into the
background.  Without this option, C<st-bootstrap-openldap> will pause on the
console waiting for you to hit ^C to stop the instance.

=item --dataset <ldif>

Specifies an LDIF file to use as the data set to be loaded into OpenLDAP.  If
no data set is specified, a built-in default data set will be used instead.

=back

=item B<stop>

Stops any running OpenLDAP instance.

=item B<status>

Checks to see if an OpenLDAP instance is running.

=item B<delete> E<lt>dnE<gt>

Deletes the given DN from the running OpenLDAP instance.

=item B<--help/-?>

Displays a brief help message.

=item B<--man>

Displays the full documentation.

=back

=head1 AUTHOR

Socialtext, Inc.  C<< <code@socialtext.com> >>

=head1 COPYRIGHT

Copyright 2008 Socialtext, Inc.,  All Rights Reserved.

=cut

__DATA__
# Base organization
dn: dc=socialtext,dc=com
objectClass: dcObject
objectClass: organization
dc: socialtext
o: socialtext dot com

# A user that only exists in LDAP
dn: cn=ldapuser,dc=socialtext,dc=com
objectClass: inetOrgPerson
cn: ldapuser
gn: LDAP
sn: User
mail: ldapuser@null.socialtext.com
userPassword: ld@pu53r

# QAs test user
dn: cn=devnull3,dc=socialtext,dc=com
objectClass: inetOrgPerson
cn: devnull3
gn: Dev Null
sn: Three
mail: devnull3@socialtext.com
userPassword: ldapd3v

# Another QA test user
dn: cn=devnullx,dc=socialtext,dc=com
objectClass: inetOrgPerson
cn: devnullx
gn: devnullx
sn: LDAP Dev
mail: devnullx@socialtext.com
userPassword: ldapd3v

# Taro Yamada (Note how gn and sn are reversed in the cn)
dn: cn=山田太郎,dc=socialtext,dc=com
objectClass: inetOrgPerson
cn: 山田太郎
gn: 太郎
sn: 山田
mail: taro.yamada@ken.socialtext.net
userPassword: ld@pu53r

dn: cn=Bjørn Sjörœnsén,dc=socialtext,dc=com
objectClass: inetOrgPerson
cn: Bjørn Sjörœnsén
gn: Bjørn
sn: Sjörœnsén
mail: bjorn@ken.socialtext.net
userPassword: ld@pu53r

# Define some Groups.
dn: cn=Motorhead,dc=socialtext,dc=com
objectClass: groupOfNames
cn: Motorhead
member: cn=Lemmy Kilmister,dc=socialtext,dc=com
member: cn=Phil Taylor,dc=socialtext,dc=com
member: cn=Eddie Clarke,dc=socialtext,dc=com

dn: cn=Lemmy Kilmister,dc=socialtext,dc=com
objectClass: inetOrgPerson
mail: lemmy@socialtext.com
gn: Lemmy
sn: Kilmister
cn: Lemmy Kilmister
displayName: Mr Rock and Roll
userPassword: ld@pu53r
telephoneNumber: 604-555-1212

dn: cn=Killingsworthy,dc=socialtext,dc=com
objectClass: inetOrgPerson
mail: Killingsworthy@socialtext.com
gn: Robert
sn: Costello
cn: Killingsworthy
displayName: Software Dev Manager
UserPassword: ld@pu53r
telephoneNumber: 605-555-1212

dn: cn=Phil Taylor,dc=socialtext,dc=com
objectClass: inetOrgPerson
mail: phil@socialtext.com
gn: Phil
sn: Taylor
cn: Phil Taylor
displayName: Filthy Phil
userPassword: ld@pu53r
telephoneNumber: 250-123-4567

dn: cn=Eddie Clarke,dc=socialtext,dc=com
objectClass: inetOrgPerson
mail: eddie@socialtext.com
gn: Eddie
sn: Clarke
cn: Eddie Clarke
displayName: Fast Eddie
userPassword: ld@pu53r
telephoneNumber: 416-987-6543

dn: cn=Hawkwind,dc=socialtext,dc=com
objectClass: groupOfNames
cn: Hawkwind
member: cn=Motorhead,dc=socialtext,dc=com
member: cn=Michael Moorcock,dc=socialtext,dc=com

dn: cn=Michael Moorcock,dc=socialtext,dc=com
objectClass: inetOrgPerson
mail: michael@socialtext.com
gn: Michael
initials: John
sn: Moorcock
cn: Michael Moorcock
userPassword: ld@pu53r

# Define a User with a Manager
dn: cn=Sharon Osbourne,dc=socialtext,dc=com
objectClass: inetOrgPerson
mail: sharon@socialtext.com
gn: Sharon
initials: Rachel
sn: Osbourne
cn: Sharon Osbourne
userPassword: ld@pu53r

dn: cn=Ozzy Osbourne,dc=socialtext,dc=com
objectClass: inetOrgPerson
mail: ozzy@socialtext.com
gn: Ozzy
sn: Osbourne
cn: Ozzy Osbourne
displayName: The Prince of Darkness
userPassword: ld@pu53r
manager: cn=Sharon Osbourne,dc=socialtext,dc=com
